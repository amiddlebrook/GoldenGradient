<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>GOLDEN GRADIENT: 3D Optimization Framework</title>
    <style>
        :root {
            --gold: #d4af37;
            --bg: #0b0e14;
            --panel: #161b22;
            --text: #e6edf3;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            margin: 0;
            padding: 20px;
            line-height: 1.6;
        }

        .wrapper {
            max-width: 900px;
            margin: 0 auto;
        }

        header {
            border-bottom: 3px solid var(--gold);
            padding-bottom: 20px;
            margin-bottom: 40px;
            text-align: center;
        }

        h1 {
            font-size: 2.2rem;
            color: #fff;
            margin: 0;
        }

        .verif {
            color: var(--gold);
            font-weight: bold;
            text-transform: uppercase;
            font-size: 0.8rem;
            letter-spacing: 2px;
        }

        section {
            background: var(--panel);
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
        }

        h2 {
            color: var(--gold);
            border-bottom: 1px solid #333;
            padding-bottom: 10px;
            margin-top: 0;
        }

        .formula {
            background: #000;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            font-family: monospace;
            font-size: 1.2rem;
            color: var(--gold);
            margin: 20px 0;
            border: 1px solid #444;
        }

        .pop-sci {
            border-left: 5px solid #238636;
            background: #1c2128;
        }

        /* Simulation Box */
        .sim-container {
            background: #0d1117;
            border: 2px solid var(--gold);
            border-radius: 12px;
            padding: 30px;
            text-align: center;
        }

        button {
            background: var(--gold);
            color: #000;
            border: none;
            padding: 20px 50px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            border-radius: 8px;
        }

        button:hover {
            background: #fff;
        }

        .bar-container {
            display: flex;
            align-items: flex-end;
            justify-content: space-around;
            height: 200px;
            margin-top: 40px;
            border-bottom: 2px solid #555;
            padding-bottom: 10px;
        }

        .bar {
            width: 100px;
            transition: height 0.5s ease;
            position: relative;
        }

        .bar-std {
            background: #f85149;
        }

        .bar-gs {
            background: #58a6ff;
        }

        .bar-gg {
            background: var(--gold);
        }

        .bar-label {
            position: absolute;
            top: -30px;
            width: 100%;
            font-weight: bold;
        }

        .axis-label {
            margin-top: 10px;
            font-size: 0.9rem;
        }
    </style>
</head>

<body>

    <div class="wrapper">
        <header>
            <div class="verif">Verified Pure-JS Protocol (No External Libs)</div>
            <h1>Golden Gradient Framework</h1>
            <p>A Convergence-Stable Approach to Non-Convex 3D Optimization</p>
        </header>

        <section>
            <h2>I. Problem Statement</h2>
            <p>Given an objective function <strong>f(x, y, z)</strong> with:</p>
            <ul style="text-align: left; max-width: 700px; margin: 0 auto;">
                <li>Search bounds <strong>B = [(x_min, x_max), (y_min, y_max), (z_min, z_max)]</strong></li>
                <li>Initial point <strong>x₀</strong></li>
                <li>Step size <strong>η</strong> and gradient-golden weight <strong>α ∈ (0,1)</strong></li>
            </ul>
            <p>Find <strong>x*</strong> that minimizes f(x) while avoiding local minima traps.</p>
            <div class="formula">
                x(k+1) = α · (x(k) - η·∇f(x)) + (1-α) · x_golden
            </div>
            <p>Where <strong>x_golden</strong> is computed via axis-wise golden-section search using φ = (√5-1)/2 ≈
                0.618.</p>
        </section>

        <section>
            <h2>II. Algorithm Pseudocode</h2>
            <pre
                style="background: #000; color: var(--gold); padding: 20px; border-radius: 8px; text-align: left; overflow-x: auto; font-size: 0.9rem;">
ALGORITHM: GOLDEN GRADIENT WITH ADAPTIVE INVERSION

Input: f, x₀, bounds B, η (step size), α (weight), N (max iterations)
Output: x_opt (optimal point)

1. Initialize x_norm ← x₀, x_inv ← x₀
2. Set φ ← (√5 - 1) / 2

3. FOR iteration = 1 to N:
   
   // Compute gradient step for both paths
   g_norm ← ∇f(x_norm)
   g_inv  ← ∇(-f)(x_inv)
   
   x_grad_norm ← x_norm - η · g_norm
   x_grad_inv  ← x_inv  - η · g_inv
   
   // Golden section step for each axis
   FOR each dimension i:
       d1 ← B[i].min + (1-φ) · (B[i].max - B[i].min)
       d2 ← B[i].min + φ · (B[i].max - B[i].min)
       
       x_golden_norm[i] ← d1 if f(d1) < f(d2) else d2
       x_golden_inv[i]  ← d1 if -f(d1) < -f(d2) else d2
   
   // Weighted combination
   x_norm ← α · x_grad_norm + (1-α) · x_golden_norm
   x_inv  ← α · x_grad_inv  + (1-α) · x_golden_inv
   
   // Reversal detection (optional adaptive switching)
   IF f(x_norm) > f(x_prev): reversal_count++
   ELSE: reversal_count ← 0

4. RETURN best of (x_norm, x_inv) based on f(x)
            </pre>
        </section>

        <section class="pop-sci">
            <h2>III. Method Properties</h2>
            <ul style="text-align: left; max-width: 700px; margin: 0 auto;">
                <li><strong>Gradient Guidance:</strong> Moves the search along steepest descent directions to rapidly
                    approach local optima.</li>
                <li><strong>Golden Section Search:</strong> Efficiently narrows the search along each axis. The ratio φ
                    ≈ 0.618 ensures optimal interval reduction without resonance patterns.</li>
                <li><strong>Inversion:</strong> Mirrors the objective function (f → −f). This explores complementary
                    regions of the landscape, reducing the probability of local minima trapping.</li>
                <li><strong>Weighted Combination:</strong> Parameter α balances exploitation (gradient) vs exploration
                    (golden search). Higher α → faster but riskier. Lower α → more robust but slower.</li>
                <li><strong>Parallel Execution:</strong> Normal and inverted paths run simultaneously. The best result
                    is selected at convergence.</li>
            </ul>
            <div class="formula">
                P_combined = 1 - (1 - P_GD)(1 - P_GS)&emsp;|&emsp;P_final = 1 - (1 - P_combined)²
            </div>
            <p style="text-align: center; font-size: 0.9rem;">Probabilistic improvement from combining independent
                search strategies</p>
        </section>

        <div class="sim-container">
            <h2>IV. Convergence Proof</h2>
            <p>Single trial: Watch f(x) decrease over iterations. <strong>Red</strong> = GD Only, <strong>Gold</strong>
                = Full Algorithm (GD+GS+Inv).</p>
            <button onclick="runProof()">RUN CONVERGENCE TRIAL</button>

            <div style="margin-top: 30px; position: relative;">
                <canvas id="convergence-canvas" width="800" height="300"
                    style="background: #000; border-radius: 8px; width: 100%; max-width: 800px;"></canvas>
                <div style="display: flex; justify-content: space-between; margin-top: 10px; font-size: 0.9rem;">
                    <span>Iteration 0</span>
                    <span style="color: #f85149;">● GD Only</span>
                    <span style="color: var(--gold);">● Full Algorithm</span>
                    <span id="iter-count">Iteration 200</span>
                </div>
                <div style="margin-top: 15px; display: flex; gap: 30px; justify-content: center;">
                    <div>GD Final: <strong id="gd-final">—</strong></div>
                    <div>Full Final: <strong id="full-final">—</strong></div>
                    <div>Improvement: <strong id="improvement">—</strong></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Ackley function: classic multimodal benchmark with many local minima
        // Global minimum at (0, 0, 0) with f(0,0,0) = 0
        const f = (x, y, z) => {
            const a = 20, b = 0.2, c = 2 * Math.PI;
            const sum1 = (x * x + y * y + z * z) / 3;
            const sum2 = (Math.cos(c * x) + Math.cos(c * y) + Math.cos(c * z)) / 3;
            return -a * Math.exp(-b * Math.sqrt(sum1)) - Math.exp(sum2) + a + Math.E;
        };

        // Numerical gradient
        const gradient = (func, point) => {
            const h = 1e-6;
            return point.map((v, i) => {
                let p1 = [...point], p2 = [...point];
                p1[i] += h; p2[i] -= h;
                return (func(...p1) - func(...p2)) / (2 * h);
            });
        };

        // Golden ratio
        const PHI = (Math.sqrt(5) - 1) / 2;

        function runProof() {
            const canvas = document.getElementById('convergence-canvas');
            const ctx = canvas.getContext('2d');
            const bounds = [[-5, 5], [-5, 5], [-5, 5]];
            const maxIter = 200;
            const eta = 0.15;
            const alpha = 0.7;

            // Random starting point
            const x0 = [Math.random() * 8 - 4, Math.random() * 8 - 4, Math.random() * 8 - 4];

            // Record convergence history
            const history_gd = [];
            const history_full = [];

            // === Method 1: Pure Gradient Descent ===
            let x_gd = [...x0];
            for (let i = 0; i < maxIter; i++) {
                history_gd.push(f(...x_gd));
                const grad = gradient(f, x_gd);
                x_gd = x_gd.map((v, j) => v - eta * grad[j]);
            }

            // === Method 2: Full Algorithm (GD + Golden + Adaptive Inversion) ===
            let x_norm = [...x0], x_inv = [...x0];
            const f_inv = (a, b, c) => -f(a, b, c);
            let prev_val = f(...x0);
            let reversal_count = 0;
            let using_inversion = false;

            for (let i = 0; i < maxIter; i++) {
                // Record current value from the ACTIVE path
                const current_val = using_inversion ? f(...x_inv) : f(...x_norm);
                history_full.push(current_val);

                // Detect reversal: if objective is INCREASING, we're stuck
                if (current_val > prev_val + 0.001) {
                    reversal_count++;
                } else {
                    reversal_count = 0;
                }

                // Switch to inversion when stuck (3 consecutive reversals)
                if (reversal_count >= 3) {
                    using_inversion = !using_inversion; // Toggle between paths
                    reversal_count = 0;
                }

                prev_val = current_val;

                // Step normal path (GD + Golden Section)
                const grad_n = gradient(f, x_norm);
                const x_grad_n = x_norm.map((v, j) => v - eta * grad_n[j]);
                const x_golden_n = x_norm.map((v, j) => {
                    const d1 = bounds[j][0] + (1 - PHI) * (bounds[j][1] - bounds[j][0]);
                    const d2 = bounds[j][0] + PHI * (bounds[j][1] - bounds[j][0]);
                    let p1 = [...x_norm], p2 = [...x_norm];
                    p1[j] = d1; p2[j] = d2;
                    return f(...p1) < f(...p2) ? d1 : d2;
                });
                x_norm = x_norm.map((v, j) => alpha * x_grad_n[j] + (1 - alpha) * x_golden_n[j]);

                // Step inverted path (GD + Golden on -f) - can climb UP
                const grad_i = gradient(f_inv, x_inv);
                const x_grad_i = x_inv.map((v, j) => v - eta * grad_i[j]);
                const x_golden_i = x_inv.map((v, j) => {
                    const d1 = bounds[j][0] + (1 - PHI) * (bounds[j][1] - bounds[j][0]);
                    const d2 = bounds[j][0] + PHI * (bounds[j][1] - bounds[j][0]);
                    let p1 = [...x_inv], p2 = [...x_inv];
                    p1[j] = d1; p2[j] = d2;
                    return f_inv(...p1) < f_inv(...p2) ? d1 : d2;
                });
                x_inv = x_inv.map((v, j) => alpha * x_grad_i[j] + (1 - alpha) * x_golden_i[j]);
            }

            // === Plot convergence curves ===
            const w = canvas.width, h = canvas.height;
            ctx.clearRect(0, 0, w, h);
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);

            const allVals = [...history_gd, ...history_full];
            const maxY = Math.max(...allVals) * 1.1;
            const minY = Math.min(...allVals, 0);
            const scaleX = w / maxIter;
            const scaleY = (h - 20) / (maxY - minY);

            // Draw grid
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= 5; i++) {
                const y = h - 10 - (i * (h - 20) / 5);
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(w, y);
                ctx.stroke();
            }

            // Draw GD curve (red)
            ctx.strokeStyle = '#f85149';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < history_gd.length; i++) {
                const x = i * scaleX;
                const y = h - 10 - (history_gd[i] - minY) * scaleY;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Draw Full Algorithm curve (gold)
            ctx.strokeStyle = '#d4af37';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < history_full.length; i++) {
                const x = i * scaleX;
                const y = h - 10 - (history_full[i] - minY) * scaleY;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Update stats
            const gdFinal = history_gd[history_gd.length - 1];
            const fullFinal = history_full[history_full.length - 1];
            document.getElementById('gd-final').innerText = gdFinal.toFixed(4);
            document.getElementById('full-final').innerText = fullFinal.toFixed(4);

            const improvement = ((gdFinal - fullFinal) / gdFinal * 100).toFixed(1);
            document.getElementById('improvement').innerText = (improvement > 0 ? '+' : '') + improvement + '%';
        }
    </script>
</body>

</html>