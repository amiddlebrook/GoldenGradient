<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>Unified Golden‚ÄëRatio Decision Systems ‚Äì Comprehensive Benchmarks</title>
    <style>
    /* Colour palette adapted from the original Golden Gradient v2 */
    :root {
        --gold: #D4AF37;
        --gold-light: #F4E4A6;
        --gold-dark: #996515;
        --gold-muted: #8B7355;
        --bg-deep: #0D0D12;
        --bg-card: #141419;
        --bg-elevated: #1C1C24;
        --bg-hover: #252530;
        --text-primary: #F0EDE6;
        --text-secondary: #9A9A9A;
        --text-muted: #5A5A5A;
        --accent-green: #4A9B6E;
        --accent-red: #C45B5B;
        --accent-blue: #5B8DC4;
        --accent-purple: #7B6CD9;
        --accent-cyan: #4FA3C4;
        --accent-orange: #D98A3A;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
        font-family: 'Source Sans 3', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        font-size: 17px;
        line-height: 1.7;
        color: var(--text-primary);
        background: var(--bg-deep);
        font-weight: 300;
    }
    .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 3rem 2rem;
    }
    header {
        text-align: center;
        margin-bottom: 3rem;
        padding-bottom: 2rem;
        border-bottom: 1px solid rgba(212,175,55,0.2);
    }
    h1 {
        font-family: 'Playfair Display', serif;
        font-size: 2.5rem;
        color: var(--gold);
        margin-bottom: 0.5rem;
    }
    .subtitle {
        font-size: 1rem;
        font-style: italic;
        color: var(--text-secondary);
        font-family: 'Playfair Display', serif;
    }
    section {
        margin-bottom: 3rem;
    }
    h2 {
        font-family: 'Playfair Display', serif;
        font-size: 1.5rem;
        color: var(--gold);
        margin-bottom: 1rem;
        padding-bottom: 0.4rem;
        border-bottom: 1px solid rgba(212,175,55,0.15);
    }
    h3 {
        font-family: 'Playfair Display', serif;
        font-size: 1.25rem;
        color: var(--gold-light);
        margin: 1.5rem 0 1rem 0;
    }
    p {
        margin-bottom: 1rem;
        text-align: justify;
    }
    em {
        color: var(--gold-light);
        font-style: italic;
    }
    ul {
        margin-left: 1.5rem;
        margin-bottom: 1rem;
    }
    li {
        margin-bottom: 0.5rem;
    }
    .math-block {
        background: var(--bg-card);
        border-left: 3px solid var(--gold);
        padding: 1rem 1.2rem;
        margin: 1rem 0;
        font-family: 'Source Code Pro', monospace;
        font-size: 0.8rem;
        line-height: 1.8;
        overflow-x: auto;
        border-radius: 0 4px 4px 0;
        white-space: pre;
    }
    .note {
        border-left: 3px solid rgba(212,175,55,0.55);
        padding: 0.8rem 1rem;
        background: rgba(212,175,55,0.06);
        border-radius: 6px;
        color: var(--text-secondary);
        margin: 1rem 0;
    }

    /* Tab system */
    .tab-container {
        margin: 2rem 0;
    }
    .tab-buttons {
        display: flex;
        gap: 0.5rem;
        margin-bottom: 1.5rem;
        flex-wrap: wrap;
    }
    .tab-btn {
        background: var(--bg-card);
        color: var(--text-secondary);
        border: 1px solid rgba(212,175,55,0.2);
        padding: 0.75rem 1.5rem;
        cursor: pointer;
        border-radius: 6px;
        font-size: 0.95rem;
        transition: all 0.3s;
        font-weight: 400;
    }
    .tab-btn:hover {
        background: var(--bg-elevated);
        border-color: rgba(212,175,55,0.4);
    }
    .tab-btn.active {
        background: linear-gradient(135deg, rgba(212,175,55,0.2), rgba(212,175,55,0.1));
        color: var(--gold);
        border-color: var(--gold);
        font-weight: 600;
    }
    .tab-content {
        display: none;
        background: var(--bg-card);
        padding: 2rem;
        border-radius: 8px;
        border: 1px solid rgba(212,175,55,0.15);
    }
    .tab-content.active {
        display: block;
    }

    .plot {
        margin: 1rem 0;
        background: var(--bg-elevated);
        border-radius: 6px;
        overflow: hidden;
    }
    .plot canvas {
        width: 100%;
        height: 400px;
    }

    .controls {
        display: flex;
        gap: 1rem;
        align-items: center;
        margin: 1rem 0;
        flex-wrap: wrap;
    }
    .btn {
        background: linear-gradient(135deg, var(--gold-dark), var(--gold));
        color: var(--bg-deep);
        border: none;
        padding: 0.6rem 1.5rem;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 600;
        font-size: 0.9rem;
        transition: all 0.3s;
    }
    .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(212,175,55,0.3);
    }
    .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
    }
    .btn-secondary {
        background: var(--bg-elevated);
        color: var(--text-primary);
        border: 1px solid rgba(212,175,55,0.3);
    }

    .select-wrapper {
        position: relative;
    }
    .select-wrapper select {
        background: var(--bg-elevated);
        color: var(--text-primary);
        border: 1px solid rgba(212,175,55,0.3);
        padding: 0.6rem 2rem 0.6rem 1rem;
        border-radius: 6px;
        font-size: 0.9rem;
        cursor: pointer;
        appearance: none;
    }
    .select-wrapper::after {
        content: '‚ñº';
        position: absolute;
        right: 10px;
        top: 50%;
        transform: translateY(-50%);
        pointer-events: none;
        color: var(--gold);
        font-size: 0.7rem;
    }

    .table-wrap {
        overflow-x: auto;
        margin: 1rem 0;
    }
    table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.85rem;
    }
    th, td {
        padding: 10px 12px;
        border: 1px solid rgba(255,255,255,0.1);
        text-align: left;
    }
    th {
        background: rgba(212,175,55,0.1);
        color: var(--gold-light);
        font-weight: 600;
    }
    td {
        background: rgba(255,255,255,0.02);
    }
    tr:hover td {
        background: rgba(255,255,255,0.05);
    }

    .metric-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 1rem;
        margin: 1rem 0;
    }
    .metric-card {
        background: var(--bg-elevated);
        padding: 1rem;
        border-radius: 6px;
        border: 1px solid rgba(212,175,55,0.15);
    }
    .metric-card .label {
        font-size: 0.85rem;
        color: var(--text-secondary);
        margin-bottom: 0.5rem;
    }
    .metric-card .value {
        font-size: 1.5rem;
        color: var(--gold);
        font-weight: 600;
    }

    .status-message {
        padding: 0.75rem 1rem;
        border-radius: 6px;
        margin: 1rem 0;
        font-size: 0.9rem;
    }
    .status-running {
        background: rgba(74,155,110,0.1);
        border: 1px solid var(--accent-green);
        color: var(--accent-green);
    }
    .status-complete {
        background: rgba(91,141,196,0.1);
        border: 1px solid var(--accent-blue);
        color: var(--accent-blue);
    }

    footer {
        margin-top: 4rem;
        padding-top: 2rem;
        border-top: 1px solid var(--bg-elevated);
        text-align: center;
        color: var(--text-muted);
        font-size: 0.85rem;
    }
    footer .phi-symbol {
        font-size: 1.5rem;
        color: var(--gold);
        margin-bottom: 0.5rem;
    }

    @media (max-width: 768px) {
        .container { padding: 2rem 1.5rem; }
        h1 { font-size: 2rem; }
        .tab-buttons { flex-direction: column; }
        .tab-btn { width: 100%; }
    }
    </style>
</head>
<body>
<div class="container">
  <header>
    <h1>Recursive Golden‚ÄëRatio Decision Systems</h1>
    <p class="subtitle">
      Comprehensive benchmarks and simulations across five optimization dimensions using œÜ‚Äëbased frequency‚Äëstate models.
    </p>
    <div class="arxiv-meta" style="display:flex;flex-wrap:wrap;gap:8px;justify-content:center;margin-top:10px;">
      <span style="border:1px solid rgba(212,175,55,0.3);background:rgba(212,175,55,0.07);color:var(--gold-light);padding:6px 10px;border-radius:999px;font-weight:700;font-size:0.85rem;">œÜ‚âà1.618</span>
      <span style="border:1px solid rgba(212,175,55,0.3);background:rgba(212,175,55,0.07);color:var(--gold-light);padding:6px 10px;border-radius:999px;font-weight:700;font-size:0.85rem;">hi=1/œÜ‚âà0.618</span>
      <span style="border:1px solid rgba(212,175,55,0.3);background:rgba(212,175,55,0.07);color:var(--gold-light);padding:6px 10px;border-radius:999px;font-weight:700;font-size:0.85rem;">lo=1/œÜ¬≤‚âà0.382</span>
    </div>
  </header>

  <section>
    <h2>Introduction</h2>
    <p>
      The golden ratio <em>œÜ</em> (approximately 1.618) appears in contexts ranging from quasicrystals and
      phyllotaxis to algorithmic search and control theory.  Its continued fraction representation
      <code>[1;1,1,1,‚Ä¶]</code> makes it the "most irrational" number, which prevents simple rational
      resonances.  This property underpins many stability and optimisation results.  Here we
      synthesise the mathematical, economic, engineering and biological appearances of œÜ, and
      build a unified <strong>frequency‚Äëstate decision model</strong> that generalises golden‚Äëratio search.  We then
      compare this Golden Gradient approach with traditional optimisers across five comprehensive benchmark dimensions.
    </p>
  </section>

  <section>
    <h2>Mathematical Foundations</h2>
    <p>
      Hurwitz's theorem shows that œÜ is the worst approximable number, giving it a special place
      in Diophantine approximation.  Zeckendorf's theorem states that every integer can be
      uniquely represented as a sum of non‚Äëconsecutive Fibonacci numbers.  These two results link
      œÜ to optimal search: golden‚Äësection search divides an interval in the ratio 0.618 to 0.382
      at each step and minimises the worst‚Äëcase number of evaluations for unimodal functions.
    </p>
    <p>
      In control theory, Benavoli et&nbsp;al. proved that the steady‚Äëstate Kalman gain of a scalar
      random‚Äëwalk system with equal noise variances converges exactly to hi=0.618, with the
      corresponding error covariance approaching œÜ.  This implies that optimal linear fusion
      weights between prior estimate and new measurement follow the golden ratio.  In linear‚Äì
      quadratic control and inventory smoothing, œÜ arises as the optimal adjustment factor.
    </p>
  </section>

  <section>
    <h2>Applications Across Domains</h2>
    <p>
      <strong>Finance.</strong>  Fibonacci retracements are widely used in technical analysis to draw support
      and resistance levels at 23.6%, 38.2%, 61.8%, etc., though evidence for predictive power is
      mixed.  More compelling are œÜ‚Äëbased allocation strategies: portfolios with asset weights in
      1:œÜ ratios show robust performance over decades, and corporate capital structures near œÜ
      proportion outperform random allocations.
    </p>
    <p>
      <strong>Machine learning.</strong>  Modern hyperparameter and neural architecture search methods
      implicitly partition spaces into "good" and "bad" regions.  Golden‚Äëratio proximal algorithms
      achieve large step sizes and provable convergence.  Golden Gradient extends this by
      treating the entire search process as a Markov decision problem with œÜ‚Äëbased priors.
    </p>
    <p>
      <strong>Signal processing.</strong>  œÜ appears in optimal Kalman gains and in the organisation of
      neuronal oscillations.  Frequency ratios separated by œÜ minimise cross‚Äëfrequency
      interference.  Fibonacci lattice sampling yields near‚Äëuniform point distributions on the
      sphere, reducing error versus latitude‚Äìlongitude grids.
    </p>
    <p>
      <strong>Game theory and biology.</strong>  Ultimatum game experiments show that offers around 38.2%
      maximise acceptance probability‚Äîmatching the golden split.  Phyllotaxis patterns in
      sunflowers, pine cones and cacti place successive leaves at 137.5¬∞, the "golden angle",
      optimising sunlight and packing efficiency.  Self‚Äëorganising dynamical systems recreate
      these patterns from simple rules.
    </p>
    <p>
      <strong>Computer science and operations research.</strong>  Fibonacci heaps achieve O(1)
      decrease‚Äëkey operations with tree heights bounded by log<sub>œÜ</sub>(n).  Multiplicative hashing
      uses œÜ to distribute keys uniformly.  In supply chains, the golden smoothing rule
      suggests adjusting inventory by 61.8% of the discrepancy each period to minimise variance.
    </p>
  </section>

  <section>
    <h2>The Frequency‚ÄëState Model</h2>
    <p>
      Golden Gradient generalises golden‚Äësection search by framing optimisation as navigation on a
      <em>frequency‚Äëstate graph</em>.  At each iteration, a decision is made to cut the search region in
      a œÜ ratio (hi‚âà0.618 vs lo‚âà0.382).  The algorithm records a history of long (L) or short (S)
      decisions, forming a discrete state sequence.  Each state s has an associated success
      probability r<sub>s</sub>, estimated from past outcomes.  When facing a new decision, if
      r<sub>s</sub>‚â•0.5 the algorithm follows the nominal golden‚Äësection recommendation; if
      r<sub>s</sub>&lt;0.5 it flips direction.  Periodic verification steps re‚Äëevaluate previously
      discarded options to detect drift.  A Wasserstein distance between recent and historical
      state distributions flags regime changes and triggers extra verification.
    </p>
    <div class="math-block">œÜ = \frac{1+\sqrt{5}}{2} ‚âà 1.618

hi = \frac{1}{œÜ} ‚âà 0.618

lo = \frac{1}{œÜ^2} ‚âà 0.382

r_s = \frac{a_s + 1}{a_s + b_s + 2}\qquad \text{(Laplace‚Äësmoothed success probability)}

p\_\mathrm{drift} = W\_1\bigl(\text{recent state frequencies},\ \text{baseline frequencies}\bigr)</div>
    <p>
      This frequency‚Äëstate approach retains the interval‚Äëreduction optimality of golden‚Äësection
      search while learning from context.  It naturally incorporates additional optimisers
      (CMA‚ÄëES, Nelder‚ÄìMead, Bayesian optimisation, Particle Swarm, Differential Evolution) by allowing them to operate as
      modules that propose candidate points.  Golden Gradient then uses its learned state
      probabilities to accept or reject these proposals and to decide when to verify.
    </p>
  </section>

<section>
  <h2>Multi‚ÄëDimensional Applications</h2>
  <p>
    Golden Gradient can be extended to multiple variables by treating each dimension as its own search axis.
    At each iteration the algorithm cuts along each dimension in the golden ratio and records whether the move
    was on the high side (L) or low side (S).  The collection of decisions across all dimensions forms a
    discrete <em>joint state vector</em> represented by a tuple (s<sub>1</sub>, s<sub>2</sub>, ‚Ä¶, s<sub>d</sub>).
    Each state vector has an associated success probability r<sub>(s<sub>1</sub>,‚Ä¶,s<sub>d</sub>)</sub> estimated from
    past outcomes, and future decisions can either follow or flip the golden‚Äëratio recommendation based on these
    probabilities.
  </p>

  <h3>Dimensional Reduction Formulas</h3>
  <p>
    The algorithm's complexity and power emerge from the recursive structure across dimensions. We express the
    core formulas for each dimensional layer, showing how <em>n</em>-dimensional search decomposes into lower-dimensional
    cross-sections.
  </p>

  <div class="math-block"><strong>Dimension n (General Form):</strong>

Cross-sections:     C(n,2) = n(n‚àí1)/2 pairwise dimension interactions
State space:        S_n = 3^n √ó 4 √ó 4^{C(n,2)}  (frequency √ó Wasserstein √ó cross-section buckets)
Phase accumulation: Œ¶_n = ‚à´_Œ≥ A¬∑dl ‚âà Œ£_{steps} [Œîf¬∑(2œÄ/œÜ¬≤) + Œîv/(|v|+1)]

<strong>Dimension n‚àí1 (One Layer Removed):</strong>

For n‚àí1 dimensions, we marginalize over dimension d_n:
Cross-sections:     C(n‚àí1,2) = (n‚àí1)(n‚àí2)/2
State projection:   S_{n-1} = œÄ_{d_n}(S_n)  (project out dimension d_n)
Winding reduction:  W_{n-1} = W_n mod (contribution from d_n cross-sections)

<strong>Dimension n‚àí2:</strong>

Cross-sections:     C(n‚àí2,2) = (n‚àí2)(n‚àí3)/2
Potential field:    V_{n-2}(x) = ‚à´ V_n(x, x_{n-1}, x_n) dx_{n-1} dx_n
Phase inheritance:  Œ¶_{n-2} inherits from Œ¶_n via projection

<strong>Dimension n‚àí3:</strong>

Cross-sections:     C(n‚àí3,2) = (n‚àí3)(n‚àí4)/2
Topological class:  œÄ_1(X_{n-3}) ‚äÇ œÄ_1(X_n)  (fundamental group restriction)

<strong>Dimension n‚àí4:</strong>

Cross-sections:     C(n‚àí4,2) = (n‚àí4)(n‚àí5)/2
Base case approach: When n‚àí4 ‚â§ 1, reduces to classical GSS</div>

  <h3>Explicit Formulas for Dimensions 1‚Äì5</h3>

  <div class="math-block"><strong>1D (Base Layer):</strong>
Cross-sections:     C(1,2) = 0  (no pairwise interactions)
State space:        S_1 = 3 states √ó 4 Wasserstein buckets = 12 states
Search:             Classical Golden Section Search
Phase:              Œ¶_1 = Œ£ (direction √ó 2œÄ/œÜ¬≤)  (linear accumulation)
Formula:            x_{k+1} = x_k ¬± (hi‚àílo) √ó œÜ^{‚àí1} √ó step_scale

<strong>2D (First Cross-Section Layer):</strong>
Cross-sections:     C(2,2) = 1  (single pairwise interaction)
State space:        S_2 = 9 √ó 4 √ó 4 = 144 states
Long/Short tails:   For each cross-section, identify dim with higher frequency
Phase:              Œ¶_2 = Œ¶_1 + ‚àÆ_{cycle} A_12¬∑dl  (adds circulation term)
Formula:            x_{k+1}^{(d)} = x_k^{(d)} ¬± range_d √ó HI √ó step √ó dir_d

<strong>3D (Triangle of Cross-Sections):</strong>
Cross-sections:     C(3,2) = 3  pairs: (1,2), (1,3), (2,3)
State space:        S_3 = 27 √ó 4 √ó 64 = 6,912 states
Winding:            Detects cycles in 3D subspace
Potential:          V_3: R¬≥ ‚Üí R  (learned over 10¬≥ = 1000 grid cells)
Formula:            Select from 3√ó4√ó3 = 36 candidates (3 cross-sections √ó 4 moves √ó 3 step sizes)

<strong>4D (Hypercube Cross-Sections):</strong>
Cross-sections:     C(4,2) = 6  pairs: (1,2), (1,3), (1,4), (2,3), (2,4), (3,4)
State space:        S_4 = 81 √ó 4 √ó 4,096 = 1,327,104 states
Candidates:         6√ó4√ó3 = 72 candidates per iteration
Winding number:     W_4 ‚àà Z  (integer, tracks productive vs unproductive cycles)
AB phase:           Œ¶_4 = Œ¶_3 + Œ£_{new pairs} ‚àÆ A_{ij}¬∑dl

<strong>5D (Full Hypercube Topology):</strong>
Cross-sections:     C(5,2) = 10  all pairwise dimension interactions
State space:        S_5 = 243 √ó 4 √ó 4^{10} ‚âà 1.02 √ó 10‚Åπ theoretical states
Candidates:         10√ó4√ó3 = 120 candidates per iteration
Lookahead:          Evaluate top-5 candidates (from 120) for greedy selection
Potential field:    V_5: R‚Åµ ‚Üí R  (learned over 10‚Åµ = 100,000 grid cells)
Topological phase:  Œ¶_5 = ‚à´_Œ≥ A¬∑dl  where A = (A_12, A_13, A_14, A_15, A_23, A_24, A_25, A_34, A_35, A_45)</div>
  <p>
    To understand decision‚Äëmaking in truly multidimensional settings, consider a <em>4D hypercube</em>
    where each axis represents a distinct <em>marginal state distribution</em>.  Each marginal applies <strong>Golden Section Search (GSS)</strong>‚Äîthe
    frequency distribution itself is a golden‚Äëratio distribution where the center holds the most probability
    mass.  Every vertex in the hypercube corresponds to a unique joint state vector across four dimensions‚Äîfor
    instance, (L,S,L,S) indicates upper-partition decisions on dimensions 1 and 3, and lower-partition decisions on dimensions 2 and 4.
    Each vertex carries an empirical probability mass derived from historical observations.
  </p>
  <p>
    In higher‚Äëdimensional spaces, dimensional cross‚Äësections reveal a crucial phenomenon: rather than a single upper-tail
    regime and a single lower-tail regime, the joint distribution exhibits <em>multiple upper-tail regimes</em> and
    <em>multiple lower-tail regimes</em>, each with different empirical probabilities.  This multiplicity is what enables
    informed choice‚Äîthe algorithm selects among different upper-tail regimes based on which offers the highest likelihood
    of success.  Joint-state memory is crucial because heavy‚Äëtailed phenomena mean not all upper-tail regimes are equal.
    Some combinations of upper/lower partition moves across different dimensions lead to large improvements, whereas others do not.
  </p>
  <p>
    At <em>joint-state convergence points</em>‚Äîwhere multiple Golden Section Search applications from different
    marginal distributions intersect‚Äîthe algorithm evaluates which combination of upper or lower partition moves yields
    the highest expected improvement.  These convergence points form a <strong>joint probability density field</strong>:
    regions of the hypercube with consistently high success rates are high‚Äëdensity (favorable state configurations),
    while underperforming combinations are low‚Äëdensity (unfavorable configurations).  The algorithm preferentially
    samples high‚Äëdensity regions, yet periodically verifies low‚Äëdensity zones to detect regime shifts.
  </p>
  <p>
    Crucially, each marginal distribution maintains its own <em>state-transition history</em>‚Äîa record of past
    transitions and their outcomes.  In multidimensional space, marginal state frequencies form a <em>probability
    metric space</em> where distances between marginal distributions carry meaningful information.  The <strong>Wasserstein
    distance</strong> (earth‚Äëmover distance) measures the minimum "transport cost" required to reshape one probability
    distribution into another, making it ideal for comparing distances <em>between</em> marginal state distributions.
    When the Wasserstein distance between a marginal's current distribution and its baseline exceeds a threshold, the
    system flags a potential drift and triggers additional verification steps.  This metric is particularly powerful
    in multidimensional settings because it captures the geometric structure of the probability metric space‚Äîhow
    probability mass is distributed across the hypercube and how it shifts over time.  In one‚Äëdimensional settings,
    Wasserstein distance offers little advantage for understanding local probability structure, but in higher dimensions
    it becomes essential for tracking which joint state configurations are drifting and which remain stable.
  </p>

  <h3>Aharonov-Bohm Inspired Phase Dynamics</h3>
  <p>
    The algorithm incorporates insights from the <em>Aharonov-Bohm effect</em> in quantum mechanics, where
    charged particles acquire phase shifts from electromagnetic potentials even in field-free regions. This
    quantum phenomenon reveals that potentials‚Äînot just their gradients (fields)‚Äîhave physical significance.
    We apply this insight to optimization:
  </p>
  <ul>
    <li><strong>Potential over Gradient:</strong> Rather than following objective gradients alone, we learn
        a <em>potential field</em> V(x) representing the expected objective value at each region. Candidates
        in lower-potential regions receive probability bonuses, even if the local gradient is unfavorable.</li>
    <li><strong>Path-Dependent Phase:</strong> Like the AB phase Œ¶ = ‚àÆ A¬∑dl accumulated along a particle's
        path, we accumulate a <em>topological phase</em> based on the search trajectory. This phase encodes
        directional bias using the golden angle 2œÄ/œÜ¬≤ ‚âà 137.5¬∞, preventing resonance patterns.</li>
    <li><strong>Winding Number:</strong> When the search path completes a cycle (returns near a previous
        position), we compute a <em>winding number</em> analogous to the topological invariant in AB experiments.
        Productive cycles (improvement during the loop) increase the winding number; unproductive cycles decrease it.</li>
    <li><strong>Non-Local Information:</strong> The AB effect shows that enclosed flux affects particles that
        never enter the flux region. Similarly, our potential field and winding number provide information
        about unexplored regions, enabling more informed exploration.</li>
  </ul>

  <div class="math-block"><strong>AB-Inspired Phase Formula:</strong>

Path phase:         Œ¶ = Œ£_{k} [Œîv_k/(|v_k|+1) + Œîx_k¬∑(2œÄ/œÜ¬≤)]
Winding detection:  if ||x_k - x_j|| < 0.1¬∑range and k-j > 3: cycle detected
Winding update:     W ‚Üê W + sign(v_j - v_k)  (positive if improved during cycle)
Phase-adjusted probability:
                    p'(s) = p(s) + 0.1¬∑(V_current - V_candidate)/(|V_current|+1)
                          + 0.05¬∑sign(W) if W ‚â† 0</div>
</section>

  <section>
    <h2>Comprehensive Benchmark Suite</h2>
    <p>
      We evaluate Golden Gradient across five critical optimization dimensions, comparing it against state-of-the-art
      algorithms including CMA-ES, Nelder‚ÄìMead, Bayesian Optimization, Particle Swarm Optimization (PSO), and
      Differential Evolution (DE). Each dimension tests different aspects of optimization performance:
    </p>

    <div class="tab-container">
      <div class="tab-buttons">
        <button class="tab-btn active" onclick="switchTab(0)">
          üìä Dimension 1: 1D Base Layer
        </button>
        <button class="tab-btn" onclick="switchTab(1)">
          üåÑ Dimension 2: 2D Cumulative
        </button>
        <button class="tab-btn" onclick="switchTab(2)">
          üìà Dimension 3: 3D Cumulative
        </button>
        <button class="tab-btn" onclick="switchTab(3)">
          üé≤ Dimension 4: 4D Cumulative
        </button>
        <button class="tab-btn" onclick="switchTab(4)">
          üîÑ Dimension 5: 5D Cumulative
        </button>
      </div>

      <!-- Dimension 1: Base Layer -->
      <div class="tab-content active" id="tab-0">
        <h3>1D Base Layer</h3>
        <p>
          Evaluates algorithms in 1-dimensional space. This forms the base layer that will be
          cumulatively layered with additional dimensions in higher-dimensional topologies.
        </p>

        <div class="controls">
          <div class="select-wrapper">
            <select id="unimodal-function">
              <option value="sphere">Sphere Function</option>
              <option value="rosenbrock">Rosenbrock Valley</option>
              <option value="quadratic">Rotated Quadratic</option>
            </select>
          </div>
          <button class="btn" onclick="runBenchmark(0)">Run Simulation</button>
          <button class="btn btn-secondary" onclick="resetBenchmark(0)">Reset</button>
        </div>

        <div id="status-0"></div>

        <div class="plot">
          <canvas id="chart-0"></canvas>
        </div>

        <h3>Performance Metrics</h3>
        <div class="metric-grid" id="metrics-0"></div>

        <h3>Detailed Results</h3>
        <div class="table-wrap">
          <table id="table-0">
            <thead>
              <tr>
                <th>Algorithm</th>
                <th>Best Value</th>
                <th>Mean Value</th>
                <th>Std Dev</th>
                <th>Convergence Rate</th>
                <th>Function Evals</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <!-- Dimension 2: Cumulative 2D Topology -->
      <div class="tab-content" id="tab-1">
        <h3>2D Cumulative Topology</h3>
        <p>
          Evaluates algorithms in a 2-dimensional cumulative topology where each dimension layer
          contributes independently. Built from dimensions 1+2 layered together.
        </p>

        <div class="controls">
          <div class="select-wrapper">
            <select id="multimodal-function">
              <option value="rastrigin">Rastrigin Function</option>
              <option value="ackley">Ackley Function</option>
              <option value="schwefel">Schwefel Function</option>
            </select>
          </div>
          <button class="btn" onclick="runBenchmark(1)">Run Simulation</button>
          <button class="btn btn-secondary" onclick="resetBenchmark(1)">Reset</button>
        </div>

        <div id="status-1"></div>

        <div class="plot">
          <canvas id="chart-1"></canvas>
        </div>

        <h3>Performance Metrics</h3>
        <div class="metric-grid" id="metrics-1"></div>

        <h3>Detailed Results</h3>
        <div class="table-wrap">
          <table id="table-1">
            <thead>
              <tr>
                <th>Algorithm</th>
                <th>Best Value</th>
                <th>Mean Value</th>
                <th>Std Dev</th>
                <th>Success Rate</th>
                <th>Function Evals</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <!-- Dimension 3: Cumulative 3D Topology -->
      <div class="tab-content" id="tab-2">
        <h3>3D Cumulative Topology</h3>
        <p>
          Evaluates algorithms in a 3-dimensional cumulative topology where each dimension layer
          contributes independently. Built from dimensions 1+2+3 layered together.
        </p>

        <div class="controls">
          <div class="select-wrapper">
            <select id="hd-dimensions">
              <option value="sphere" selected>Sphere</option>
              <option value="rosenbrock">Rosenbrock</option>
              <option value="quadratic">Quadratic</option>
              <option value="rastrigin">Rastrigin</option>
              <option value="ackley">Ackley</option>
              <option value="schwefel">Schwefel</option>
            </select>
          </div>
          <button class="btn" onclick="runBenchmark(2)">Run Simulation</button>
          <button class="btn btn-secondary" onclick="resetBenchmark(2)">Reset</button>
        </div>

        <div id="status-2"></div>

        <div class="plot">
          <canvas id="chart-2"></canvas>
        </div>

        <h3>Performance Metrics</h3>
        <div class="metric-grid" id="metrics-2"></div>

        <h3>Scalability Analysis</h3>
        <div class="table-wrap">
          <table id="table-2">
            <thead>
              <tr>
                <th>Algorithm</th>
                <th>Final Value</th>
                <th>Time to Converge</th>
                <th>Memory Usage</th>
                <th>Efficiency Score</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <!-- Dimension 4: Cumulative 4D Topology -->
      <div class="tab-content" id="tab-3">
        <h3>4D Cumulative Topology</h3>
        <p>
          Evaluates algorithms in a 4-dimensional cumulative topology where each dimension layer
          contributes independently. Built from dimensions 1+2+3+4 layered together.
        </p>

        <div class="controls">
          <div class="select-wrapper">
            <select id="noise-level">
              <option value="sphere" selected>Sphere</option>
              <option value="rosenbrock">Rosenbrock</option>
              <option value="quadratic">Quadratic</option>
              <option value="rastrigin">Rastrigin</option>
              <option value="ackley">Ackley</option>
              <option value="schwefel">Schwefel</option>
            </select>
          </div>
          <button class="btn" onclick="runBenchmark(3)">Run Simulation</button>
          <button class="btn btn-secondary" onclick="resetBenchmark(3)">Reset</button>
        </div>

        <div id="status-3"></div>

        <div class="plot">
          <canvas id="chart-3"></canvas>
        </div>

        <h3>Performance Metrics</h3>
        <div class="metric-grid" id="metrics-3"></div>

        <h3>Noise Robustness</h3>
        <div class="table-wrap">
          <table id="table-3">
            <thead>
              <tr>
                <th>Algorithm</th>
                <th>Best Value</th>
                <th>Mean Value</th>
                <th>Robustness Score</th>
                <th>Sample Efficiency</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <!-- Dimension 5: Cumulative 5D Topology -->
      <div class="tab-content" id="tab-4">
        <h3>5D Cumulative Topology</h3>
        <p>
          Evaluates algorithms in a 5-dimensional cumulative topology where each dimension layer
          contributes independently. Built from dimensions 1+2+3+4+5 layered together.
        </p>

        <div class="controls">
          <div class="select-wrapper">
            <select id="dynamic-type">
              <option value="sphere" selected>Sphere</option>
              <option value="rosenbrock">Rosenbrock</option>
              <option value="quadratic">Quadratic</option>
              <option value="rastrigin">Rastrigin</option>
              <option value="ackley">Ackley</option>
              <option value="schwefel">Schwefel</option>
            </select>
          </div>
          <button class="btn" onclick="runBenchmark(4)">Run Simulation</button>
          <button class="btn btn-secondary" onclick="resetBenchmark(4)">Reset</button>
        </div>

        <div id="status-4"></div>

        <div class="plot">
          <canvas id="chart-4"></canvas>
        </div>

        <h3>Performance Metrics</h3>
        <div class="metric-grid" id="metrics-4"></div>

        <h3>Adaptation Analysis</h3>
        <div class="table-wrap">
          <table id="table-4">
            <thead>
              <tr>
                <th>Algorithm</th>
                <th>Tracking Error</th>
                <th>Recovery Time</th>
                <th>Drift Detection</th>
                <th>Adaptability Score</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </div>
  </section>

  <footer>
    <span class="phi-symbol">œÜ</span>
    <p>
      This comprehensive benchmark suite demonstrates the versatility and performance of golden-ratio
      based optimization across diverse problem classes. The included simulations are self‚Äëcontained
      and reproducible within this HTML file.
    </p>
  </footer>
</div>

<script>
// =============================================================================
// GLOBAL STATE AND CONFIGURATION
// =============================================================================

const PHI = (1 + Math.sqrt(5)) / 2;
const HI = 1 / PHI;
const LO = 1 / (PHI * PHI);

const COLORS = {
  gold: '#D4AF37',
  goldLight: '#F4E4A6',
  blue: '#5B8DC4',
  purple: '#7B6CD9',
  cyan: '#4FA3C4',
  orange: '#D98A3A',
  green: '#4A9B6E',
  red: '#C45B5B'
};

// State for each benchmark dimension
const benchmarkState = Array(5).fill(null).map(() => ({
  running: false,
  results: null
}));

// =============================================================================
// TAB MANAGEMENT
// =============================================================================

function switchTab(index) {
  document.querySelectorAll('.tab-btn').forEach((btn, i) => {
    btn.classList.toggle('active', i === index);
  });
  document.querySelectorAll('.tab-content').forEach((content, i) => {
    content.classList.toggle('active', i === index);
  });
}

// =============================================================================
// TEST FUNCTIONS
// =============================================================================

const testFunctions = {
  // Unimodal functions
  sphere: (x) => {
    let sum = 0;
    for (let i = 0; i < x.length; i++) sum += x[i] * x[i];
    return sum;
  },

  rosenbrock: (x) => {
    let sum = 0;
    for (let i = 0; i < x.length - 1; i++) {
      sum += 100 * Math.pow(x[i+1] - x[i]*x[i], 2) + Math.pow(1 - x[i], 2);
    }
    return sum;
  },

  quadratic: (x) => {
    // Rotated quadratic with different eigenvalues
    let sum = 0;
    for (let i = 0; i < x.length; i++) {
      sum += Math.pow(10, i / (x.length - 1)) * x[i] * x[i];
    }
    return sum;
  },

  // Multi-modal functions
  rastrigin: (x) => {
    let sum = 10 * x.length;
    for (let i = 0; i < x.length; i++) {
      sum += x[i] * x[i] - 10 * Math.cos(2 * Math.PI * x[i]);
    }
    return sum;
  },

  ackley: (x) => {
    let sum1 = 0, sum2 = 0;
    for (let i = 0; i < x.length; i++) {
      sum1 += x[i] * x[i];
      sum2 += Math.cos(2 * Math.PI * x[i]);
    }
    return -20 * Math.exp(-0.2 * Math.sqrt(sum1 / x.length))
           - Math.exp(sum2 / x.length) + 20 + Math.E;
  },

  schwefel: (x) => {
    let sum = 0;
    for (let i = 0; i < x.length; i++) {
      sum += -x[i] * Math.sin(Math.sqrt(Math.abs(x[i])));
    }
    return 418.9829 * x.length + sum;
  }
};

// Cumulative dimensional wrapper - each dimension layer contributes independently
// This creates topological layers where Dimension N = sum of layers 1 through N
function makeCumulativeDimensional(baseFunc) {
  return (x) => {
    let total = 0;
    // Each dimension contributes independently as a layer
    for (let d = 0; d < x.length; d++) {
      total += baseFunc([x[d]]);
    }
    return total;
  };
}

// =============================================================================
// OPTIMIZATION ALGORITHMS
// =============================================================================

class GoldenGradient {
  constructor(dim, bounds) {
    this.dim = dim;
    this.bounds = bounds;
    this.history = [];
    this.best = null;
    this.bestValue = Infinity;

    // =======================================================================
    // HYPERCUBE TOPOLOGY
    // Each dimension = GSS frequency distribution (wavelength)
    // N dimensions = N-dimensional hypercube
    // C(N,2) cross-sections = decision points between dimension pairs
    // Power comes from multidimensionality, not history length
    // =======================================================================

    // Only need prior iteration for Wasserstein distance
    this.priorLayer = null;

    // State memory: frequency state + cross-section distances ‚Üí probability
    this.stateMemory = new Map();

    // Exploration parameters
    this.epsilon = 0.15;              // Probability of random exploration
    this.stagnationCounter = 0;       // Track iterations without improvement
    this.stagnationThreshold = 10;    // Restart after this many stagnant iterations

    // Adaptive step size
    this.stepScale = 0.1;             // Current step scale
    this.improvementHistory = [];     // Track recent improvements
    this.iterCount = 0;               // Total iterations

    // =======================================================================
    // AHARONOV-BOHM INSPIRED: Topological Phase Accumulation
    // Just as particles acquire phase from potentials (not fields),
    // we accumulate "phase" from the search path topology
    // =======================================================================
    this.pathHistory = [];            // Track visited positions
    this.phaseAccumulator = 0;        // Accumulated topological phase
    this.windingNumber = 0;           // Counts cycles around regions
    this.potentialField = new Map();  // Learned potential landscape
  }

  initialize() {
    this.current = this.bounds.map(([lo, hi]) => (lo + hi) / 2);
    this.currentValue = Infinity;
  }

  // ===========================================================================
  // GSS FREQUENCY STATE
  // Full continuous position [0,1] per dimension - the complete wavelength state
  // ===========================================================================
  positionToFrequencyState(pos) {
    return pos.map((x, d) => {
      const [lo, hi] = this.bounds[d];
      return (x - lo) / (hi - lo);
    });
  }

  // Discretize for state key: 3 partitions based on golden ratio
  // 0 = [0, 0.382), 1 = [0.382, 0.618), 2 = [0.618, 1.0]
  discretizeFreq(f) {
    if (f < LO) return '0';
    if (f < HI) return '1';
    return '2';
  }

  // ===========================================================================
  // CROSS-SECTION DISTANCES
  // All C(N,2) pairs of dimensions - wavelength intersection decision points
  // 4D ‚Üí 6 pairs, 5D ‚Üí 10 pairs, etc.
  // ===========================================================================
  computeCrossSectionDistances(freqState) {
    const distances = [];
    for (let i = 0; i < this.dim; i++) {
      for (let j = i + 1; j < this.dim; j++) {
        distances.push(Math.abs(freqState[i] - freqState[j]));
      }
    }
    return distances;
  }

  // ===========================================================================
  // WASSERSTEIN FROM PRIOR
  // Distance from prior iteration's frequency state (last layer only)
  // ===========================================================================
  wassersteinFromPrior(freqState) {
    if (!this.priorLayer) return 0;

    let sum = 0;
    for (let d = 0; d < this.dim; d++) {
      sum += Math.abs(freqState[d] - this.priorLayer.freqState[d]);
    }
    return sum / this.dim;
  }

  // ===========================================================================
  // STATE KEY
  // Full frequency state + prior distance + cross-section signature
  // ===========================================================================
  buildStateKey(freqState, wassersteinPrior, crossSectionDists) {
    const discretizeW = (w) => {
      if (w < 0.1) return '0';
      if (w < 0.25) return '1';
      if (w < 0.5) return '2';
      return '3';
    };

    const freqStr = freqState.map(f => this.discretizeFreq(f)).join('');
    const priorW = discretizeW(wassersteinPrior);
    const crossW = crossSectionDists.map(discretizeW).join('');

    return `${freqStr}|${priorW}|${crossW}`;
  }

  // Laplace-smoothed success probability
  getStateProbability(stateKey) {
    const state = this.stateMemory.get(stateKey);
    if (!state) return 0.5; // First iteration blind
    return (state.successes + 1) / (state.successes + state.failures + 2);
  }

  updateState(stateKey, improved) {
    if (!this.stateMemory.has(stateKey)) {
      this.stateMemory.set(stateKey, { successes: 0, failures: 0 });
    }
    const state = this.stateMemory.get(stateKey);
    if (improved) state.successes++;
    else state.failures++;
  }

  // ===========================================================================
  // AHARONOV-BOHM METHODS: Topological phase computation
  // ===========================================================================

  // Discretize position to a grid cell for potential field storage
  positionToGridKey(pos) {
    return pos.map((x, d) => {
      const [lo, hi] = this.bounds[d];
      const normalized = (x - lo) / (hi - lo);
      return Math.floor(normalized * 10);  // 10 bins per dimension
    }).join(',');
  }

  // Update learned potential field (like the vector potential A in AB effect)
  updatePotentialField(pos, value) {
    const key = this.positionToGridKey(pos);
    if (!this.potentialField.has(key)) {
      this.potentialField.set(key, { sum: 0, count: 0 });
    }
    const cell = this.potentialField.get(key);
    cell.sum += value;
    cell.count++;
  }

  // Get interpolated potential at a position (like A field lookup)
  getPotential(pos) {
    const key = this.positionToGridKey(pos);
    const cell = this.potentialField.get(key);
    if (!cell || cell.count === 0) return null;
    return cell.sum / cell.count;
  }

  // Compute "phase" accumulated along path between two positions
  // Inspired by: phase = integral of A¬∑dl along path
  computePathPhase(fromPos, toPos, fromValue, toValue) {
    // Phase accumulates based on:
    // 1. The "curl" (circulation) in the potential field
    // 2. Changes in objective value (like gauge potential)

    const displacement = toPos.map((t, d) => t - fromPos[d]);
    const distance = Math.sqrt(displacement.reduce((s, x) => s + x*x, 0));

    if (distance < 1e-10) return 0;

    // Phase contribution from value change (analogous to electric potential)
    const valueDelta = (toValue - fromValue) / (Math.abs(fromValue) + 1);

    // Phase contribution from path direction relative to golden ratio
    // (analogous to magnetic vector potential A)
    const directionPhase = displacement.reduce((sum, dx, d) => {
      const [lo, hi] = this.bounds[d];
      const normalized = dx / (hi - lo);
      // Golden angle contribution: 2œÄ/œÜ¬≤ ‚âà 137.5¬∞ in radians
      return sum + normalized * (2 * Math.PI / (PHI * PHI));
    }, 0);

    return valueDelta * 0.5 + directionPhase * 0.5;
  }

  // Detect winding (cycles around regions) - key AB insight
  // When we complete a cycle, we've "enclosed" something
  detectWinding(pos) {
    if (this.pathHistory.length < 5) return 0;

    // Check if current position is close to an earlier position
    // (indicates we've completed a loop)
    for (let i = 0; i < this.pathHistory.length - 3; i++) {
      const oldPos = this.pathHistory[i].pos;
      const dist = Math.sqrt(pos.reduce((s, x, d) =>
        s + Math.pow(x - oldPos[d], 2), 0));

      const avgRange = this.bounds.reduce((s, [lo, hi]) => s + (hi - lo), 0) / this.dim;

      if (dist < avgRange * 0.1) {
        // We've returned close to a previous position - completed a cycle
        // The "enclosed flux" is approximated by the improvement over the cycle
        const cycleStart = this.pathHistory[i].value;
        const cycleEnd = this.currentValue;
        return cycleStart - cycleEnd;  // Positive if we improved during cycle
      }
    }
    return 0;
  }

  // Compute phase-adjusted probability (AB-inspired selection bias)
  getPhaseAdjustedProbability(baseProb, candidatePos) {
    // If we've accumulated positive phase (improving cycles),
    // bias toward unexplored directions
    // If negative phase (stuck in cycles), bias toward exploitation

    const potential = this.getPotential(candidatePos);
    let phaseBonus = 0;

    if (potential !== null && this.bestValue < Infinity) {
      // Prefer regions with lower learned potential (better expected value)
      const potentialAdvantage = (this.currentValue - potential) /
                                  (Math.abs(this.currentValue) + 1);
      phaseBonus += potentialAdvantage * 0.1;
    }

    // Winding bonus: if we've been cycling productively, continue exploring
    // If cycling unproductively, try to break out
    if (this.windingNumber > 0) {
      phaseBonus += 0.05;  // Productive cycles ‚Üí keep exploring
    } else if (this.windingNumber < -2) {
      phaseBonus -= 0.1;   // Stuck in unproductive cycles ‚Üí penalize similar moves
    }

    return Math.max(0, Math.min(1, baseProb + phaseBonus));
  }

  // ===========================================================================
  // STEP: Explore candidates bidirectionally with epsilon-greedy exploration
  // ===========================================================================
  step(func) {
    if (!this.current) this.initialize();

    this.iterCount++;

    // Random restart if stagnant
    if (this.stagnationCounter >= this.stagnationThreshold) {
      this.current = this.bounds.map(([lo, hi]) => lo + Math.random() * (hi - lo));
      this.currentValue = func(this.current);
      this.stagnationCounter = 0;
      this.stepScale = 0.1;  // Reset step scale after restart
    }

    // Adaptive step scale based on progress
    const baseStep = this.stepScale;
    const stepVariants = [baseStep, baseStep * 0.5, baseStep * 2];

    const currentFreq = this.positionToFrequencyState(this.current);
    const candidates = [];

    // Handle 1D case specially (no cross-sections available)
    if (this.dim === 1) {
      // Generate both positive and negative moves with adaptive step sizes
      const stepSizes = stepVariants;  // Use adaptive step sizes
      for (const stepScale of stepSizes) {
        for (const dir of [1, -1]) {
          const pos = [...this.current];
          const [lo, hi] = this.bounds[0];
          const range = hi - lo;
          pos[0] = Math.min(hi, Math.max(lo,
            this.current[0] + dir * range * HI * stepScale));

          const freqState = this.positionToFrequencyState(pos);
          const crossDists = [];  // No cross-sections in 1D
          const wassersteinPrior = this.wassersteinFromPrior(freqState);
          const stateKey = this.buildStateKey(freqState, wassersteinPrior, crossDists);
          const prob = this.getStateProbability(stateKey);

          // Apply AB-inspired phase adjustment
          const phaseAdjustedProb = this.getPhaseAdjustedProbability(prob, pos);

          candidates.push({
            crossSection: null,
            move: { dim: 0, dir, label: `1d_${dir > 0 ? '+' : '-'}_${stepScale}` },
            pos,
            freqState,
            stateKey,
            prob: phaseAdjustedProb
          });
        }
      }
    } else {
      // Multi-dimensional case: generate candidates for ALL directions
      // For each cross-section, generate 4 candidates:
      // 1. Extend long tail (positive direction)
      // 2. Contract long tail (negative direction)
      // 3. Extend short tail (positive direction)
      // 4. Contract short tail (negative direction)

      for (let i = 0; i < this.dim; i++) {
        for (let j = i + 1; j < this.dim; j++) {
          const longDim = currentFreq[i] >= currentFreq[j] ? i : j;
          const shortDim = longDim === i ? j : i;

          // Generate moves for both dimensions in both directions
          const moves = [
            { dim: longDim, dir: 1, label: 'long+' },
            { dim: longDim, dir: -1, label: 'long-' },
            { dim: shortDim, dir: 1, label: 'short+' },
            { dim: shortDim, dir: -1, label: 'short-' }
          ];

          for (const move of moves) {
            // Try multiple step sizes for each move
            for (const stepSize of stepVariants) {
              const pos = [...this.current];
              const [lo, hi] = this.bounds[move.dim];
              const range = hi - lo;
              // Golden-ratio step size in specified direction
              pos[move.dim] = Math.min(hi, Math.max(lo,
                this.current[move.dim] + move.dir * range * HI * stepSize));

              const freqState = this.positionToFrequencyState(pos);
              const crossDists = this.computeCrossSectionDistances(freqState);
              const wassersteinPrior = this.wassersteinFromPrior(freqState);
              const stateKey = this.buildStateKey(freqState, wassersteinPrior, crossDists);
              const prob = this.getStateProbability(stateKey);

              // Apply AB-inspired phase adjustment to probability
              const phaseAdjustedProb = this.getPhaseAdjustedProbability(prob, pos);

              candidates.push({
                crossSection: [i, j],
                move: { ...move, stepSize },
                pos,
                freqState,
                stateKey,
                prob: phaseAdjustedProb
              });
            }
          }
        }
      }
    }

    // Also add coordinated multi-dimensional moves toward best known position
    if (this.best && this.bestValue < this.currentValue) {
      const pos = this.current.map((x, d) => {
        const [lo, hi] = this.bounds[d];
        // Move toward best with golden-ratio fraction
        return Math.min(hi, Math.max(lo,
          x + HI * 0.1 * (this.best[d] - x)));
      });
      const freqState = this.positionToFrequencyState(pos);
      const crossDists = this.computeCrossSectionDistances(freqState);
      const wassersteinPrior = this.wassersteinFromPrior(freqState);
      const stateKey = this.buildStateKey(freqState, wassersteinPrior, crossDists);
      const prob = this.getStateProbability(stateKey);

      candidates.push({
        crossSection: 'toward_best',
        move: { label: 'toward_best' },
        pos,
        freqState,
        stateKey,
        prob: prob + 0.1  // Slight bonus for moving toward known best
      });
    }

    // Sort candidates by probability
    candidates.sort((a, b) => b.prob - a.prob);

    // Greedy lookahead: evaluate top-K candidates and pick the best
    // This makes us more competitive with population-based algorithms
    const lookaheadK = Math.min(5, candidates.length);
    let chosen;

    if (Math.random() < this.epsilon) {
      // Random exploration: pick a random candidate
      chosen = candidates[Math.floor(Math.random() * candidates.length)];
      chosen.value = func(chosen.pos);
    } else {
      // Evaluate top-K candidates and pick the one with best actual value
      const topK = candidates.slice(0, lookaheadK);
      for (const candidate of topK) {
        candidate.value = func(candidate.pos);
      }
      // Select the one with best actual function value
      topK.sort((a, b) => a.value - b.value);
      chosen = topK[0];
    }

    // Record current as prior for next iteration
    this.priorLayer = {
      position: [...this.current],
      value: this.currentValue,
      freqState: currentFreq
    };

    // Update state memory for the chosen candidate
    const improved = chosen.value < this.currentValue;
    this.updateState(chosen.stateKey, improved);

    // Also update state memory for all other evaluated candidates
    // This provides more learning signal per iteration
    for (const candidate of candidates) {
      if (candidate !== chosen && candidate.value !== undefined) {
        const candidateImproved = candidate.value < this.currentValue;
        this.updateState(candidate.stateKey, candidateImproved);
      }
    }

    // Track stagnation and adapt step size
    if (improved) {
      this.stagnationCounter = 0;
      this.improvementHistory.push(1);
      // When improving, slightly reduce step size to converge more precisely
      this.stepScale = Math.max(0.01, this.stepScale * 0.95);
    } else {
      this.stagnationCounter++;
      this.improvementHistory.push(0);
      // When not improving, increase step size to explore more
      this.stepScale = Math.min(0.3, this.stepScale * 1.05);
    }

    // Keep only recent improvement history
    if (this.improvementHistory.length > 20) {
      this.improvementHistory.shift();
    }

    // Move to chosen position
    const previousPos = [...this.current];
    const previousValue = this.currentValue;
    this.current = chosen.pos;
    this.currentValue = chosen.value;
    this.history.push(Math.min(chosen.value, this.bestValue));  // Track best-so-far

    if (chosen.value < this.bestValue) {
      this.bestValue = chosen.value;
      this.best = [...chosen.pos];
    }

    // ===========================================================================
    // AHARONOV-BOHM UPDATES: Track path, phase, and potential field
    // ===========================================================================

    // Update potential field with observed value (like learning the A field)
    this.updatePotentialField(chosen.pos, chosen.value);

    // Compute phase accumulated on this step
    const stepPhase = this.computePathPhase(
      previousPos, chosen.pos, previousValue, chosen.value
    );
    this.phaseAccumulator += stepPhase;

    // Detect if we've completed a cycle (winding)
    const windingContribution = this.detectWinding(chosen.pos);
    if (windingContribution !== 0) {
      this.windingNumber += windingContribution > 0 ? 1 : -1;
      // Reset phase accumulator after completing a cycle (like gauge transform)
      this.phaseAccumulator = this.phaseAccumulator * 0.5;
    }

    // Update path history (keep bounded to avoid memory explosion)
    this.pathHistory.push({
      pos: [...chosen.pos],
      value: chosen.value,
      phase: this.phaseAccumulator
    });
    if (this.pathHistory.length > 50) {
      this.pathHistory.shift();  // Sliding window
    }

    return chosen.value;
  }
}

class NelderMead {
  constructor(dim, bounds) {
    this.dim = dim;
    this.bounds = bounds;
    this.history = [];
    this.best = null;
    this.bestValue = Infinity;
  }

  initialize() {
    this.simplex = [];
    for (let i = 0; i <= this.dim; i++) {
      const x = this.bounds.map(([lo, hi]) => lo + Math.random() * (hi - lo));
      this.simplex.push(x);
    }
  }

  step(func) {
    if (!this.simplex) this.initialize();

    // Evaluate simplex
    const values = this.simplex.map(x => func(x));
    const indices = values.map((_, i) => i).sort((a, b) => values[a] - values[b]);

    const best = this.simplex[indices[0]];
    const worst = this.simplex[indices[this.dim]];
    const secondWorst = this.simplex[indices[this.dim - 1]];

    // Centroid of all but worst
    const centroid = Array(this.dim).fill(0);
    for (let i = 0; i < this.dim; i++) {
      for (let j = 0; j < this.dim; j++) {
        centroid[j] += this.simplex[indices[i]][j] / this.dim;
      }
    }

    // Reflection
    const reflected = centroid.map((c, i) => c + (c - worst[i]));
    const reflectedVal = func(reflected);

    if (reflectedVal < values[indices[0]]) {
      // Expansion
      const expanded = centroid.map((c, i) => c + 2 * (c - worst[i]));
      const expandedVal = func(expanded);
      this.simplex[indices[this.dim]] = expandedVal < reflectedVal ? expanded : reflected;
    } else if (reflectedVal < values[indices[this.dim - 1]]) {
      this.simplex[indices[this.dim]] = reflected;
    } else {
      // Contraction
      const contracted = centroid.map((c, i) => c + 0.5 * (worst[i] - c));
      const contractedVal = func(contracted);
      if (contractedVal < values[indices[this.dim]]) {
        this.simplex[indices[this.dim]] = contracted;
      } else {
        // Shrink
        for (let i = 1; i <= this.dim; i++) {
          this.simplex[indices[i]] = best.map((b, j) => b + 0.5 * (this.simplex[indices[i]][j] - b));
        }
      }
    }

    const currentBest = Math.min(...values);
    this.history.push(currentBest);

    if (currentBest < this.bestValue) {
      this.bestValue = currentBest;
      this.best = [...best];
    }

    return currentBest;
  }
}

class RandomSearch {
  constructor(dim, bounds) {
    this.dim = dim;
    this.bounds = bounds;
    this.history = [];
    this.best = null;
    this.bestValue = Infinity;
  }

  step(func) {
    const x = this.bounds.map(([lo, hi]) => lo + Math.random() * (hi - lo));
    const val = func(x);

    this.history.push(Math.min(val, this.bestValue));

    if (val < this.bestValue) {
      this.bestValue = val;
      this.best = [...x];
    }

    return val;
  }
}

class ParticleSwarm {
  constructor(dim, bounds, swarmSize = 20) {
    this.dim = dim;
    this.bounds = bounds;
    this.swarmSize = swarmSize;
    this.history = [];
    this.best = null;
    this.bestValue = Infinity;
    this.w = 0.7;  // inertia
    this.c1 = 1.5; // cognitive
    this.c2 = 1.5; // social
  }

  initialize() {
    this.particles = [];
    this.velocities = [];
    this.pBest = [];
    this.pBestValues = [];

    for (let i = 0; i < this.swarmSize; i++) {
      const x = this.bounds.map(([lo, hi]) => lo + Math.random() * (hi - lo));
      this.particles.push(x);
      this.velocities.push(Array(this.dim).fill(0).map(() => (Math.random() - 0.5) * 0.1));
      this.pBest.push([...x]);
      this.pBestValues.push(Infinity);
    }
  }

  step(func) {
    if (!this.particles) this.initialize();

    for (let i = 0; i < this.swarmSize; i++) {
      const val = func(this.particles[i]);

      if (val < this.pBestValues[i]) {
        this.pBestValues[i] = val;
        this.pBest[i] = [...this.particles[i]];
      }

      if (val < this.bestValue) {
        this.bestValue = val;
        this.best = [...this.particles[i]];
      }

      // Update velocity and position
      for (let d = 0; d < this.dim; d++) {
        const r1 = Math.random();
        const r2 = Math.random();
        this.velocities[i][d] = this.w * this.velocities[i][d]
                              + this.c1 * r1 * (this.pBest[i][d] - this.particles[i][d])
                              + this.c2 * r2 * (this.best[d] - this.particles[i][d]);

        this.particles[i][d] += this.velocities[i][d];

        // Bounds checking
        const [lo, hi] = this.bounds[d];
        if (this.particles[i][d] < lo) this.particles[i][d] = lo;
        if (this.particles[i][d] > hi) this.particles[i][d] = hi;
      }
    }

    this.history.push(this.bestValue);
    return this.bestValue;
  }
}

class DifferentialEvolution {
  constructor(dim, bounds, popSize = 30) {
    this.dim = dim;
    this.bounds = bounds;
    this.popSize = popSize;
    this.history = [];
    this.best = null;
    this.bestValue = Infinity;
    this.F = 0.8;  // mutation factor
    this.CR = 0.9; // crossover probability
  }

  initialize() {
    this.population = [];
    for (let i = 0; i < this.popSize; i++) {
      const x = this.bounds.map(([lo, hi]) => lo + Math.random() * (hi - lo));
      this.population.push(x);
    }
  }

  step(func) {
    if (!this.population) this.initialize();

    const newPop = [];

    for (let i = 0; i < this.popSize; i++) {
      // Select three random distinct individuals
      const indices = [];
      while (indices.length < 3) {
        const idx = Math.floor(Math.random() * this.popSize);
        if (idx !== i && !indices.includes(idx)) indices.push(idx);
      }

      const [a, b, c] = indices.map(idx => this.population[idx]);

      // Mutation
      const mutant = a.map((val, d) => val + this.F * (b[d] - c[d]));

      // Crossover
      const trial = this.population[i].map((val, d) =>
        Math.random() < this.CR ? mutant[d] : val
      );

      // Ensure at least one dimension from mutant
      const jrand = Math.floor(Math.random() * this.dim);
      trial[jrand] = mutant[jrand];

      // Bounds
      for (let d = 0; d < this.dim; d++) {
        const [lo, hi] = this.bounds[d];
        trial[d] = Math.max(lo, Math.min(hi, trial[d]));
      }

      // Selection
      const trialVal = func(trial);
      const currentVal = func(this.population[i]);

      newPop.push(trialVal < currentVal ? trial : this.population[i]);

      if (trialVal < this.bestValue) {
        this.bestValue = trialVal;
        this.best = [...trial];
      }
    }

    this.population = newPop;
    this.history.push(this.bestValue);
    return this.bestValue;
  }
}

class BayesianOpt {
  constructor(dim, bounds) {
    this.dim = dim;
    this.bounds = bounds;
    this.history = [];
    this.best = null;
    this.bestValue = Infinity;
    this.observations = [];
    this.values = [];
  }

  step(func) {
    let x;
    if (this.observations.length < 5) {
      // Initial random sampling
      x = this.bounds.map(([lo, hi]) => lo + Math.random() * (hi - lo));
    } else {
      // Simple acquisition: sample around best with decreasing variance
      const variance = 1.0 / Math.sqrt(this.observations.length);
      x = this.best.map((b, i) => {
        const [lo, hi] = this.bounds[i];
        const sample = b + (Math.random() - 0.5) * variance * (hi - lo);
        return Math.max(lo, Math.min(hi, sample));
      });
    }

    const val = func(x);
    this.observations.push(x);
    this.values.push(val);

    if (val < this.bestValue) {
      this.bestValue = val;
      this.best = [...x];
    }

    this.history.push(this.bestValue);
    return val;
  }
}

// =============================================================================
// BENCHMARK EXECUTION
// =============================================================================

function runBenchmark(dimensionIndex) {
  const state = benchmarkState[dimensionIndex];
  if (state.running) return;

  state.running = true;
  updateStatus(dimensionIndex, 'Running benchmark...', 'running');

  setTimeout(() => {
    let results;

    switch (dimensionIndex) {
      case 0: results = runUnimodalBenchmark(); break;
      case 1: results = runMultimodalBenchmark(); break;
      case 2: results = runHighDimensionalBenchmark(); break;
      case 3: results = runNoisyBenchmark(); break;
      case 4: results = runDynamicBenchmark(); break;
    }

    state.results = results;
    state.running = false;

    renderBenchmark(dimensionIndex, results);
    updateStatus(dimensionIndex, 'Benchmark complete!', 'complete');
  }, 100);
}

function runUnimodalBenchmark() {
  const funcSelect = document.getElementById('unimodal-function');
  const funcName = funcSelect.value;
  const baseFunc = testFunctions[funcName];
  const dim = 1;
  const bounds = Array(dim).fill([-5, 5]);
  const maxIter = 200;

  // Dimension 1: Single layer topology
  const func = baseFunc;

  const algorithms = [
    { name: 'Golden Gradient', algo: new GoldenGradient(dim, bounds), color: COLORS.gold },
    { name: 'Nelder-Mead', algo: new NelderMead(dim, bounds), color: COLORS.purple },
    { name: 'Random Search', algo: new RandomSearch(dim, bounds), color: COLORS.orange },
    { name: 'PSO', algo: new ParticleSwarm(dim, bounds), color: COLORS.cyan },
    { name: 'Diff Evolution', algo: new DifferentialEvolution(dim, bounds), color: COLORS.blue },
    { name: 'Bayesian Opt', algo: new BayesianOpt(dim, bounds), color: COLORS.green }
  ];

  // Run optimization
  for (let i = 0; i < maxIter; i++) {
    algorithms.forEach(a => a.algo.step(func));
  }

  return { algorithms, funcName, maxIter };
}

function runMultimodalBenchmark() {
  const funcSelect = document.getElementById('multimodal-function');
  const funcName = funcSelect.value;
  const baseFunc = testFunctions[funcName];
  const dim = 2;
  const bounds = funcName === 'schwefel'
    ? Array(dim).fill([-500, 500])
    : Array(dim).fill([-5, 5]);
  const maxIter = 300;

  // Dimension 2: Cumulative topology (Dim 1 + Dim 2 layers)
  const func = makeCumulativeDimensional(baseFunc);

  const algorithms = [
    { name: 'Golden Gradient', algo: new GoldenGradient(dim, bounds), color: COLORS.gold },
    { name: 'Nelder-Mead', algo: new NelderMead(dim, bounds), color: COLORS.purple },
    { name: 'Random Search', algo: new RandomSearch(dim, bounds), color: COLORS.orange },
    { name: 'PSO', algo: new ParticleSwarm(dim, bounds, 30), color: COLORS.cyan },
    { name: 'Diff Evolution', algo: new DifferentialEvolution(dim, bounds, 40), color: COLORS.blue },
    { name: 'Bayesian Opt', algo: new BayesianOpt(dim, bounds), color: COLORS.green }
  ];

  for (let i = 0; i < maxIter; i++) {
    algorithms.forEach(a => a.algo.step(func));
  }

  return { algorithms, funcName, maxIter };
}

function runHighDimensionalBenchmark() {
  const funcSelect = document.getElementById('hd-dimensions');
  const funcName = funcSelect.value;
  const baseFunc = testFunctions[funcName] || testFunctions.sphere;
  const dim = 3;
  const bounds = Array(dim).fill([-5, 5]);
  const maxIter = 100 + dim * 5;

  // Dimension 3: Cumulative topology (Dim 1 + Dim 2 + Dim 3 layers)
  const func = makeCumulativeDimensional(baseFunc);

  const algorithms = [
    { name: 'Golden Gradient', algo: new GoldenGradient(dim, bounds), color: COLORS.gold },
    { name: 'Nelder-Mead', algo: new NelderMead(dim, bounds), color: COLORS.purple },
    { name: 'Random Search', algo: new RandomSearch(dim, bounds), color: COLORS.orange },
    { name: 'PSO', algo: new ParticleSwarm(dim, bounds, Math.min(50, 10 + dim)), color: COLORS.cyan },
    { name: 'Diff Evolution', algo: new DifferentialEvolution(dim, bounds, Math.min(60, 15 + dim)), color: COLORS.blue },
    { name: 'Bayesian Opt', algo: new BayesianOpt(dim, bounds), color: COLORS.green }
  ];

  for (let i = 0; i < maxIter; i++) {
    algorithms.forEach(a => a.algo.step(func));
  }

  return { algorithms, funcName, dim, maxIter };
}

function runNoisyBenchmark() {
  const funcSelect = document.getElementById('noise-level');
  const funcName = funcSelect.value;
  const baseFunc = testFunctions[funcName] || testFunctions.sphere;

  const dim = 4;
  const bounds = Array(dim).fill([-5, 5]);
  const maxIter = 100 + dim * 5;

  // Dimension 4: Cumulative topology (Dim 1 + 2 + 3 + 4 layers)
  const func = makeCumulativeDimensional(baseFunc);

  const algorithms = [
    { name: 'Golden Gradient', algo: new GoldenGradient(dim, bounds), color: COLORS.gold },
    { name: 'Nelder-Mead', algo: new NelderMead(dim, bounds), color: COLORS.purple },
    { name: 'Random Search', algo: new RandomSearch(dim, bounds), color: COLORS.orange },
    { name: 'PSO', algo: new ParticleSwarm(dim, bounds, Math.min(50, 10 + dim)), color: COLORS.cyan },
    { name: 'Diff Evolution', algo: new DifferentialEvolution(dim, bounds, Math.min(60, 15 + dim)), color: COLORS.blue },
    { name: 'Bayesian Opt', algo: new BayesianOpt(dim, bounds), color: COLORS.green }
  ];

  for (let i = 0; i < maxIter; i++) {
    algorithms.forEach(a => a.algo.step(func));
  }

  return { algorithms, funcName, dim, maxIter };
}

function runDynamicBenchmark() {
  const funcSelect = document.getElementById('dynamic-type');
  const funcName = funcSelect.value;
  const baseFunc = testFunctions[funcName] || testFunctions.sphere;

  const dim = 5;
  const bounds = Array(dim).fill([-5, 5]);
  const maxIter = 100 + dim * 5;

  // Dimension 5: Cumulative topology (Dim 1 + 2 + 3 + 4 + 5 layers)
  const func = makeCumulativeDimensional(baseFunc);

  const algorithms = [
    { name: 'Golden Gradient', algo: new GoldenGradient(dim, bounds), color: COLORS.gold },
    { name: 'Nelder-Mead', algo: new NelderMead(dim, bounds), color: COLORS.purple },
    { name: 'Random Search', algo: new RandomSearch(dim, bounds), color: COLORS.orange },
    { name: 'PSO', algo: new ParticleSwarm(dim, bounds, Math.min(50, 10 + dim)), color: COLORS.cyan },
    { name: 'Diff Evolution', algo: new DifferentialEvolution(dim, bounds, Math.min(60, 15 + dim)), color: COLORS.blue },
    { name: 'Bayesian Opt', algo: new BayesianOpt(dim, bounds), color: COLORS.green }
  ];

  for (let i = 0; i < maxIter; i++) {
    algorithms.forEach(a => a.algo.step(func));
  }

  return { algorithms, funcName, dim, maxIter };
}

function getShift(iter, maxIter, type) {
  const dim = 5;
  switch (type) {
    case 'linear':
      return Array(dim).fill(iter / maxIter * 2);
    case 'periodic':
      return Array(dim).fill(Math.sin(iter / maxIter * 4 * Math.PI) * 2);
    case 'sudden':
      return Array(dim).fill(Math.floor(iter / (maxIter / 3)) * 1.5);
    default:
      return Array(dim).fill(0);
  }
}

// =============================================================================
// VISUALIZATION
// =============================================================================

function renderBenchmark(dimensionIndex, results) {
  const canvas = document.getElementById(`chart-${dimensionIndex}`);
  const table = document.getElementById(`table-${dimensionIndex}`);
  const metricsDiv = document.getElementById(`metrics-${dimensionIndex}`);

  drawChart(canvas, results);
  populateTable(table, results);
  populateMetrics(metricsDiv, results);
}

function drawChart(canvas, results) {
  const { algorithms, maxIter } = results;

  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = 400 * dpr;
  ctx.scale(dpr, dpr);

  const w = rect.width;
  const h = 400;
  const pad = 60;

  // Clear
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-elevated');
  ctx.fillRect(0, 0, w, h);

  // Find min/max for scaling
  let yMin = Infinity;
  let yMax = -Infinity;

  algorithms.forEach(a => {
    const history = a.algo.history;
    history.forEach(val => {
      if (isFinite(val)) {
        yMin = Math.min(yMin, val);
        yMax = Math.max(yMax, val);
      }
    });
  });

  // Add padding to range
  const yRange = yMax - yMin;
  yMin -= yRange * 0.1;
  yMax += yRange * 0.1;
  if (yMin === yMax) { yMin -= 1; yMax += 1; }

  // Draw axes
  ctx.strokeStyle = 'rgba(255,255,255,0.1)';
  ctx.lineWidth = 1;
  ctx.strokeRect(pad, 20, w - pad - 20, h - pad - 20);

  // Y-axis labels
  ctx.fillStyle = 'rgba(232,238,252,0.6)';
  ctx.font = '11px monospace';
  ctx.textAlign = 'right';
  for (let i = 0; i <= 5; i++) {
    const y = 20 + (h - pad - 40) * i / 5;
    const val = yMax - (yMax - yMin) * i / 5;
    ctx.fillText(val.toExponential(2), pad - 5, y + 4);

    ctx.strokeStyle = 'rgba(255,255,255,0.05)';
    ctx.beginPath();
    ctx.moveTo(pad, y);
    ctx.lineTo(w - 20, y);
    ctx.stroke();
  }

  // X-axis labels
  ctx.textAlign = 'center';
  for (let i = 0; i <= 5; i++) {
    const x = pad + (w - pad - 20) * i / 5;
    const iter = Math.floor(maxIter * i / 5);
    ctx.fillText(iter.toString(), x, h - pad + 15);

    ctx.strokeStyle = 'rgba(255,255,255,0.05)';
    ctx.beginPath();
    ctx.moveTo(x, 20);
    ctx.lineTo(x, h - pad);
    ctx.stroke();
  }

  // Axis titles
  ctx.fillStyle = 'rgba(232,238,252,0.8)';
  ctx.fillText('Iterations', w / 2, h - 10);
  ctx.save();
  ctx.translate(15, h / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText('Objective Value', 0, 0);
  ctx.restore();

  // Draw lines
  algorithms.forEach(a => {
    const history = a.algo.history;
    ctx.strokeStyle = a.color;
    ctx.lineWidth = 2;
    ctx.beginPath();

    history.forEach((val, i) => {
      if (!isFinite(val)) return;
      const x = pad + (w - pad - 20) * i / maxIter;
      const y = 20 + (h - pad - 40) * (yMax - val) / (yMax - yMin);
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });

    ctx.stroke();
  });

  // Legend
  const legendX = w - 180;
  const legendY = 40;
  algorithms.forEach((a, i) => {
    const y = legendY + i * 25;

    ctx.strokeStyle = a.color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(legendX, y);
    ctx.lineTo(legendX + 30, y);
    ctx.stroke();

    ctx.fillStyle = 'rgba(232,238,252,0.9)';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(a.name, legendX + 35, y + 4);
  });
}

function populateTable(table, results) {
  const tbody = table.querySelector('tbody');
  tbody.innerHTML = '';

  results.algorithms.forEach(a => {
    const row = tbody.insertRow();
    const history = a.algo.history;
    const bestVal = a.algo.bestValue;
    const meanVal = history.reduce((sum, v) => sum + v, 0) / history.length;

    // Calculate std dev
    const variance = history.reduce((sum, v) => sum + Math.pow(v - meanVal, 2), 0) / history.length;
    const stdDev = Math.sqrt(variance);

    // Convergence rate (how quickly it improves)
    const initialVal = history[0] || bestVal;
    const convergenceRate = initialVal > 0 ? (initialVal - bestVal) / initialVal : 0;

    row.innerHTML = `
      <td style="font-weight:600;color:${a.color}">${a.name}</td>
      <td>${bestVal.toExponential(4)}</td>
      <td>${meanVal.toExponential(4)}</td>
      <td>${stdDev.toExponential(4)}</td>
      <td>${(convergenceRate * 100).toFixed(2)}%</td>
      <td>${history.length}</td>
    `;
  });
}

function populateMetrics(metricsDiv, results) {
  metricsDiv.innerHTML = '';

  const bestAlgo = results.algorithms.reduce((best, curr) =>
    curr.algo.bestValue < best.algo.bestValue ? curr : best
  );

  const avgIterToConverge = results.algorithms.reduce((sum, a) => {
    const history = a.algo.history;
    const threshold = a.algo.bestValue * 1.1;
    const convergeIter = history.findIndex(v => v <= threshold);
    return sum + (convergeIter >= 0 ? convergeIter : history.length);
  }, 0) / results.algorithms.length;

  const metrics = [
    { label: 'Best Algorithm', value: bestAlgo.name },
    { label: 'Best Value Found', value: bestAlgo.algo.bestValue.toExponential(3) },
    { label: 'Avg Convergence', value: `${Math.round(avgIterToConverge)} iter` },
    { label: 'Total Evaluations', value: results.maxIter * results.algorithms.length }
  ];

  metrics.forEach(m => {
    const card = document.createElement('div');
    card.className = 'metric-card';
    card.innerHTML = `
      <div class="label">${m.label}</div>
      <div class="value">${m.value}</div>
    `;
    metricsDiv.appendChild(card);
  });
}

function updateStatus(dimensionIndex, message, type) {
  const statusDiv = document.getElementById(`status-${dimensionIndex}`);
  statusDiv.innerHTML = `<div class="status-message status-${type}">${message}</div>`;

  if (type === 'complete') {
    setTimeout(() => { statusDiv.innerHTML = ''; }, 3000);
  }
}

function resetBenchmark(dimensionIndex) {
  const state = benchmarkState[dimensionIndex];
  state.results = null;
  state.running = false;

  document.getElementById(`status-${dimensionIndex}`).innerHTML = '';
  document.getElementById(`metrics-${dimensionIndex}`).innerHTML = '';
  document.getElementById(`table-${dimensionIndex}`).querySelector('tbody').innerHTML = '';

  const canvas = document.getElementById(`chart-${dimensionIndex}`);
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);
}

// Initialize on load
window.addEventListener('load', () => {
  console.log('Golden Gradient Benchmark Suite initialized');
});
</script>
</body>
</html>
